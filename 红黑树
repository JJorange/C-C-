```c++
#include<iostream>
using namespace std;

enum COLOR{BLACK,RED};

template<class K,class V>
struct BRTreeNode
{
	BRTreeNode<K, V> * _pLeft;
	BRTreeNode<K, V> * _pRight;
	BRTreeNode<K, V> * _pParent;
	pair<K, V> _value;  // pair是一个接受两个模板参数的模板类，两个成员变量分别是first和second
	COLOR _color; // 红黑树结点的颜色

	BRTreeNode(const K& key = K(), const V& value = V(), COLOR color = RED)
		:_pLeft(NULL)
		, _pRight(NULL)
		, _pParent(NULL)
		, _value(key, value)
		, _color(color)
	{}
};


template<class K,class V>
class BRTree
{
	typedef BRTreeNode<K, V> Node;
public:
	BRTree()
		:_pRoot(NULL)
	{}

	bool InsertUnique(const pair<K,V> value)
	{
		if (_pRoot == NULL)
		{
			_pRoot = new BRTreeNode<K, V>(value.first, value.second, BLACK);
			return true;
		}

		// 找到当前插入结点
		Node * pCur = _pRoot;
		Node * pParent = NULL;
		while (pCur)
		{
			pParent = pCur;
			if (pCur->_value.first > value.first)
				pCur = pCur->_pLeft;
			else if (pCur->_value.first < value.first)
				pCur = pCur->_pRight;
			else
			{
				cout << "该值已存在！！！" << endl;
				return false;
			}
		}

		// 插入新结点
		pCur = new BRTreeNode<K, V>(value.first, value.second);
		if (pCur->_value.first < pParent->_value.first)
			pParent->_pLeft = pCur;
		else
			pParent->_pRight = pCur;

		pCur->_pParent = pParent;

		// 更新结点颜色
		while (pCur!=_pRoot && pParent->_color == RED)
		{
			Node * grandParent = pParent->_pParent;
			// 父亲结点为祖父结点的左孩子的情况
			if (pParent == grandParent->_pLeft)
			{
				Node * uncle = grandParent->_pRight;
				// 情况三：cur pParent uncle为红色结点
				// 将pParent 和 uncle 结点置为黑色，grandParent置为红色
				// 然后向上修改
				if (uncle && uncle->_color == RED)
				{
					Node * uncle = grandParent->_pRight;
					pParent->_color = BLACK;
					uncle->_color = BLACK;
					grandParent->_color = RED;
					// Cur指向grandParent方便向上修改
					pCur = grandParent;
					pParent = pCur->_pParent;
				}
				else
				{
					// 情况五：左单旋转化成情况四
					if (pCur == pParent->_pRight)
					{
						_RotateL(pParent);
						swap(pParent, pCur);
					}
					grandParent->_color = RED;
					pParent->_color = BLACK;
					// 情况四
					_RotateR(grandParent);
					swap(grandParent, pParent);
				}
			}
			else
			{
				Node * uncle = grandParent->_pLeft;
				// 情况三
				if (uncle && uncle->_color == RED)
				{
					pParent->_color = BLACK;
					uncle->_color = BLACK;
					grandParent->_color = RED;
					pCur = grandParent;
					pParent = pCur->_pParent;
				}
				else
				{
					// 情况五
					if (pCur == pParent->_pLeft)
					{
						_RotateR(pParent);
						swap(pCur, pParent);
					}
					// 情况四
					grandParent->_color = RED;
					pParent->_color = BLACK;

					_RotateL(grandParent);
				}
			}
		}
		_pRoot->_color = BLACK;

		return true;
	}

	// 前序遍历红黑树
	void show()
	{
		_show(_pRoot);
	}
private:
	Node * _pRoot;

	// 左单旋
	void _RotateL(Node * pParent)
	{
		Node * pSubR = pParent->_pRight;
		Node * pSubRL = pSubR->_pLeft;

		pParent->_pRight = pSubRL;
		if (pSubRL)
			pSubRL->_pParent = pParent;

		pSubR->_pLeft = pParent;
		Node * pPParent = pParent->_pParent;
		pParent->_pParent = pSubR;
		pSubR->_pParent = pPParent;

		if (NULL == pPParent)
			_pRoot = pSubR;
		else
		{
			if (pParent == pPParent->_pLeft)
				pPParent->_pLeft = pSubR;
			else
				pPParent->_pRight = pSubR;
		}
	}

	// 右单旋
	void _RotateR(Node * pParent)
	{
		Node * pSubL = pParent->_pLeft;
		Node * pSubLR = pSubL->_pRight;

		pParent->_pLeft = pSubLR;
		if (pSubLR)
			pSubLR->_pParent = pParent;

		pSubL->_pRight = pParent;
		Node * pPParent = pParent->_pParent;
		pParent->_pParent = pSubL;
		pSubL->_pParent = pPParent;

		if (NULL == pPParent)
			_pRoot = pSubL;
		else
		{
			if (pParent == pPParent->_pLeft)
				pPParent->_pLeft = pSubL;
			else
				pPParent->_pRight = pSubL;
		}
	}

	// 前序遍历红黑树
	void _show(Node * ptr)
	{
		if (ptr)
		{
			_show(ptr->_pLeft);
			cout << ptr->_value.first << "," << ptr->_value.second << endl;
			_show(ptr->_pRight);
		}
	}

};



int main()
{
	int arr[] = { 10, 7, 8, 15, 5, 6, 11, 13, 12 };
	BRTree<int, int> rbt;
	for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		rbt.InsertUnique(pair<int, int>(arr[i], i));
	}
	rbt.show();
	return 0;
}
```
