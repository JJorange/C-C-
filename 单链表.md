```c++
#include<stdlib.h>
#include<iostream>

using namespace std;

template<class T>
struct LinkNode	//定义成模板之后不能使用typedef
{
	T _data;//数据域
	LinkNode<T>* _pNext;//指针域

	LinkNode(LinkNode<T> * ptr = NULL)//仅初始化指针成员的构造函数
	{
		_pNext = ptr;
	}
	LinkNode(T& item, LinkNode<T>* ptr = NULL)
	{
		_data = item;
		_pNext = ptr;
	}
};


template<class T>
class List
{
public:
	List(){ pHead = new LinkList<T>; }						//构造函数
	List(const T& x){ pHead = new LinkNode<T>(x); }			//构造函数
	List(List<T>& L);										//复制构造函数
	~List(){ makeEmpty(); }									//析构函数
	void makeEmpty();										//链表置空
	int Length()const;										//求长度
	LinkNode<T> *getHead()const{ return pHead; }			//返回附加头结点地址
	LinkNode<T> *Search(T x);								//搜索数据x的位置
	LinkNode<T> *Locate(int i);								//搜索第i个元素的地址
	bool getData(int i, T& x)const;							//取第i个元素的值
	void setData(int i, T& x);								//用x修改第i个元素的值
	bool Insert(int i, T& x);								//在第i个元素后插入x
	bool Remove(int i, T& x);								//删除第i个元素的值，x为元素的值
	bool IsEmpty()const										//判空，空true
	{
		return pHead->_pNext == NULL ? true : false;
	}
	bool IsFull()const{ return false; }						//判满，true满
	void Sort();											//排序
	void input();											//输入
	void output();											//输出
	List<T>& operator=(List<T>& L);							//重载函数：赋值
private:
	LinkNode<T> * pHead;									//链表头指针
};





//template<class T>
//class List
//{
//public:
//	//构造函数
//	List()
//	{
//		pHead = new LinkNode<T>;
//	}
//
//	//构造函数
//	List(T& x)
//	{
//		pHead = new LinkNode<T>;
//		pHead->_data = x;
//	}
//
//	//复制构造函数
//	List(List<T>& L);
//
//	//析构函数
//	~List()
//	{
//		MakeEmpty();
//	}
//
//	//链表置空
//	void MakeEmpty()
//	{
//		if (pHead->_pNext == NULL)
//			exit(1);
//		LinkNode<T>* pCur,pDel;//pCur遍历 pDel删除
//		pCur = pHead->_pNext;
//		pDel = pCur;
//		while(pCur)
//		{
//			pCur = pCur->_pNext;
//			delete pDel;
//			pDel = pCur;
//		}
//	}
//	//输入
//	void inputFront(T endTag)
//	{
//		LinkNode<T> * newNode;
//		T val;
//		makeEmpty();
//		cin >> val;
//		while (val != endTag)
//		{
//			newNode = new LinkNode<T>(val);
//			if (newNode == NULL)
//			{
//				cerr << "内存分配错误!" << endl;
//				exit(1);
//			}
//			newNode->_pNext = pHead->_pNext;
//			pHead->_pNext = newNode;
//			exit(1);
//		}
//	}
//
//
//private:
//	LinkNode<T>* pHead;
//};

//int main()
//{
//	List<int> L;
//	/*L.inputFront(1);*/
//	return 0;
//}
```
